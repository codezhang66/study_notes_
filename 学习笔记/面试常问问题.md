# 面试常问问题

### 封装、继承、多态



## 成员变量和局部变量

1. 定义的位置不一样【重点】

   **局部变量：在方法的内部**

   **成员变量：在方法的外部，直接写在类当中**

2. 作用范围不一样【重点】

   **局部变量：只有在方法中才能使用**

   **成员变量：整个类都能使用**

3. 默认值不一样【重点】

   **局部变量：没有默认值，使用时必须进行赋值**

   **成员变量：有默认值，规则和数组一样**

4. 内存位置不一样【了解】

   局部变量：位于栈内存

   成员变量：位于堆内存

5. 生命周期不一样【了解】

   局部变量：随着方法的进栈而诞生，随着出栈而消失

   成员变量：随着对象的额创建而诞生，随着对象被垃圾回收而消失。







## 1、缓存（redis）

**缓存穿透**

是指缓存和数据库中都没有的数据。

解决方案：采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

**缓存击穿**

是指缓存中没有但数据库中有的数据（一般是缓存时间到期）。

解决方案：加互斥锁

**缓存雪崩**

是指缓存同一时间大面积的失效。

解决方案：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 并发不多时，加锁排队。
3. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。

**分布式锁**

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。

当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作

SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。

返回值：设置成功，返回 1 。设置失败，返回 0 。

为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间。异步续命。

释放锁，使用DEL命令将锁数据删除

**缓存一致性**

读请求和写请求串行化，串到一个内存队列里去

## 2、MQ

**消息丢失**



**消息有序可达**



**消息重复性消费**

## 3、mysql





**myisam，innodb对比：**

|              | MYISAM | INNODB        |
| ------------ | ------ | ------------- |
| 事务支持     | 不支持 | 支持          |
| 数据行锁定   | 不支持 | 支持          |
| 外键约束     | 不支持 | 支持          |
| 全文索引     | 支持   | 不支持        |
| 表空间的大小 | 较小   | 较大，约为2倍 |

常规使用操作：

- MYISAM  节约空间，速度较快  不提供事务的支持，也不支持行级锁和外键
- INNODB 安全性高，事务的处理，多表多用户操作

```
在物理空间内存在的位置
```

所有的数据库文件都存在data目录下，一个文件夹对应一个数据库。

本质还是文件的存储！、

Mysql 引擎在物理文件的区别

- INNODB 在数据库表中只有*.frm文件，以及上一级目录下的ibdata1文件

- MYISAM 对应的文件 ， 生成三个文件。

- *.frm - 表结构的定义文件

- *.MYD - 数据文件（data）

- *.MYI - 索引文件

  

**事务隔离级别**

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

#### **什么是脏读？幻读？不可重复读？**

- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

## 3、spring

**aop**



**ioc**



**spring bean 的生命周期**